{"ast":null,"code":"\"use strict\";\n\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport process from \"../process\";\nimport fetch from 'isomorphic-fetch';\nimport { ApolloClient } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { createHttpLink } from 'apollo-link-http';\nimport { isDevelopment, isClient, isServer } from \"./func\";\nconst GRAPHQL_HOST = process.env.GRAPHQL_HOST;\n\nif (!GRAPHQL_HOST) {\n  throw new Error('You must set GRAPHQL_HOST environment variable prior to using Apollo.');\n} // Polyfill fetch() if needed. Useful for server-side code.\n\n\nconst fetcher = global.fetch || fetch; // Override fetch to always include credentials.\n// @TODO: could this be done elsewhere?\n\nglobal.fetch = (uri, options = {}) => {\n  options.credentials = 'include';\n  return fetcher(uri, options);\n};\n/**\n * ID normalization. Will use, in order of precedence, a provided 'id', '_id', or\n * 'entityId' field as unique identificator, prefixed with the object's type.\n *\n * Fallbacks to default normalization system.\n *\n * @param {String} id The object's unique id.\n * @param {String} _id The object's unique id.\n * @param {String} entityId The object's unique id.\n * @param {String} __typename The object's type in GraphQL.\n *\n * @return {!String} Either a unique identificator if found, or nil.\n */\n\n\nconst dataIdFromObject = ({\n  id,\n  _id,\n  entityId,\n  __typename\n}) => id || _id || entityId ? `${__typename}:${id || _id || entityId}` : undefined;\n\nconst defaultCacheOptions = {\n  dataIdFromObject\n};\nconst typesQuery = `\n  {\n    __schema {\n      types {\n        kind\n        name\n        possibleTypes {\n          name\n        }\n      }\n    }\n  }\n`;\nlet instrospectionResult = null;\n/**\n * Loads instrospection data.\n * Performs a first non-client query to get GraphQL type\n * information. This process should run only once on the server.\n */\n\nconst getIntrospectionData = () => fetch(GRAPHQL_HOST, {\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: _JSON$stringify({\n    query: typesQuery\n  }),\n  method: 'POST'\n}).then(result => result.json()).then(result => {\n  // here we're filtering out any type information unrelated to unions or interfaces\n  const filteredData = result.data.__schema.types.filter(type => type.possibleTypes !== null);\n\n  result.data.__schema.types = filteredData;\n  return result.data;\n});\n/**\n * Instrospect the GraphQL server for type information (unions, interface, etc.).\n * Either get data from a new query execution or from an already fetched instrospetion result\n */\n\n\nexport const introspect = async () => instrospectionResult || (instrospectionResult = await getIntrospectionData());\n/**\n * Creates a new ApolloClient instance.\n *\n * @param {Object} initialState Hydrating state.\n * @return {ApolloClient}.\n */\n\nconst create = ({\n  context,\n  initialState = {},\n  cacheOptions = {}\n}) => new ApolloClient({\n  connectToDevTools: isClient() && isDevelopment(),\n  ssrMode: isServer(),\n  // Disables forceFetch on the server (so queries are only run once)\n  link: createHttpLink({\n    uri: GRAPHQL_HOST\n  }),\n  cache: new InMemoryCache(_objectSpread({}, defaultCacheOptions, cacheOptions)).restore(initialState)\n});\n\nlet apolloClient = null;\n/**\n * Initialize ApolloClient for either server ou client side.\n *\n * @param {Object} options.initialState\n * @param {Object} options.context\n * @param {Object} options.cache\n */\n\nexport default (options => isClient() // \"client-side?\"\n// On the CLIENT, always reuse any available ApolloClient instance.\n? apolloClient || (apolloClient = create(options)) // On the SERVER, always create a new ApolloClient instance.\n// @TODO: we should reconsider this. Maybe it is best to consider SSR execution\n// as an anonymous request always, and let contextual data be handled on the client,\n// thus improving performance for the majority of users, which are anonymous.\n: create(options));","map":{"version":3,"sources":["/drupal/app/next/src/lib/initApollo.js"],"names":["process","fetch","ApolloClient","InMemoryCache","createHttpLink","isDevelopment","isClient","isServer","GRAPHQL_HOST","env","Error","fetcher","global","uri","options","credentials","dataIdFromObject","id","_id","entityId","__typename","undefined","defaultCacheOptions","typesQuery","instrospectionResult","getIntrospectionData","headers","body","query","method","then","result","json","filteredData","data","__schema","types","filter","type","possibleTypes","introspect","create","context","initialState","cacheOptions","connectToDevTools","ssrMode","link","cache","restore","apolloClient"],"mappings":"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","sourcesContent":["import process from 'process'\nimport fetch from 'isomorphic-fetch'\nimport { ApolloClient } from 'apollo-client'\nimport { InMemoryCache } from 'apollo-cache-inmemory'\nimport { createHttpLink } from 'apollo-link-http'\n\nimport { isDevelopment, isClient, isServer } from 'app/lib/func'\n\nconst GRAPHQL_HOST = process.env.GRAPHQL_HOST\n\nif (!GRAPHQL_HOST) {\n  throw new Error('You must set GRAPHQL_HOST environment variable prior to using Apollo.')\n}\n\n// Polyfill fetch() if needed. Useful for server-side code.\nconst fetcher = global.fetch || fetch\n\n// Override fetch to always include credentials.\n// @TODO: could this be done elsewhere?\nglobal.fetch = (uri, options = {}) => {\n  options.credentials = 'include'\n  return fetcher(uri, options)\n}\n\n/**\n * ID normalization. Will use, in order of precedence, a provided 'id', '_id', or\n * 'entityId' field as unique identificator, prefixed with the object's type.\n *\n * Fallbacks to default normalization system.\n *\n * @param {String} id The object's unique id.\n * @param {String} _id The object's unique id.\n * @param {String} entityId The object's unique id.\n * @param {String} __typename The object's type in GraphQL.\n *\n * @return {!String} Either a unique identificator if found, or nil.\n */\nconst dataIdFromObject = ({ id, _id, entityId, __typename }) => id || _id || entityId\n  ? `${__typename}:${id || _id || entityId}`\n  : undefined\n\nconst defaultCacheOptions = { dataIdFromObject }\n\nconst typesQuery = `\n  {\n    __schema {\n      types {\n        kind\n        name\n        possibleTypes {\n          name\n        }\n      }\n    }\n  }\n`\n\nlet instrospectionResult = null\n\n/**\n * Loads instrospection data.\n * Performs a first non-client query to get GraphQL type\n * information. This process should run only once on the server.\n */\nconst getIntrospectionData = () => fetch(GRAPHQL_HOST, {\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ query: typesQuery }),\n  method: 'POST'\n})\n  .then(result => result.json())\n  .then(result => {\n    // here we're filtering out any type information unrelated to unions or interfaces\n    const filteredData = result.data.__schema.types.filter(\n      type => type.possibleTypes !== null,\n    )\n    result.data.__schema.types = filteredData\n\n    return result.data\n  })\n\n/**\n * Instrospect the GraphQL server for type information (unions, interface, etc.).\n * Either get data from a new query execution or from an already fetched instrospetion result\n */\nexport const introspect = async () => instrospectionResult || (instrospectionResult = await getIntrospectionData())\n\n/**\n * Creates a new ApolloClient instance.\n *\n * @param {Object} initialState Hydrating state.\n * @return {ApolloClient}.\n */\nconst create = ({\n  context,\n  initialState = {},\n  cacheOptions = {},\n}) => new ApolloClient({\n  connectToDevTools: isClient() && isDevelopment(),\n  ssrMode: isServer(), // Disables forceFetch on the server (so queries are only run once)\n  link: createHttpLink({ uri: GRAPHQL_HOST }),\n  cache: new InMemoryCache({ ...defaultCacheOptions, ...cacheOptions })\n    .restore(initialState)\n})\n\nlet apolloClient = null\n\n/**\n * Initialize ApolloClient for either server ou client side.\n *\n * @param {Object} options.initialState\n * @param {Object} options.context\n * @param {Object} options.cache\n */\nexport default options => isClient() // \"client-side?\"\n  // On the CLIENT, always reuse any available ApolloClient instance.\n  ? apolloClient || (apolloClient = create(options))\n\n  // On the SERVER, always create a new ApolloClient instance.\n  // @TODO: we should reconsider this. Maybe it is best to consider SSR execution\n  // as an anonymous request always, and let contextual data be handled on the client,\n  // thus improving performance for the majority of users, which are anonymous.\n  : create(options)\n"]},"metadata":{},"sourceType":"module"}