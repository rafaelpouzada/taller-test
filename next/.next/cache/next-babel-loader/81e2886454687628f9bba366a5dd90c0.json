{"ast":null,"code":"\"use strict\";\n\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport process from \"../process\";\nimport fetch from 'isomorphic-fetch';\nimport { ApolloClient } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { createHttpLink } from 'apollo-link-http';\nimport { isDevelopment, isClient, isServer } from \"./func\";\nvar GRAPHQL_HOST = process.env.GRAPHQL_HOST;\n\nif (!GRAPHQL_HOST) {\n  throw new Error('You must set GRAPHQL_HOST environment variable prior to using Apollo.');\n} // Polyfill fetch() if needed. Useful for server-side code.\n\n\nvar fetcher = global.fetch || fetch; // Override fetch to always include credentials.\n// @TODO: could this be done elsewhere?\n\nglobal.fetch = function (uri) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.credentials = 'include';\n  return fetcher(uri, options);\n};\n/**\n * ID normalization. Will use, in order of precedence, a provided 'id', '_id', or\n * 'entityId' field as unique identificator, prefixed with the object's type.\n *\n * Fallbacks to default normalization system.\n *\n * @param {String} id The object's unique id.\n * @param {String} _id The object's unique id.\n * @param {String} entityId The object's unique id.\n * @param {String} __typename The object's type in GraphQL.\n *\n * @return {!String} Either a unique identificator if found, or nil.\n */\n\n\nvar dataIdFromObject = function dataIdFromObject(_ref) {\n  var id = _ref.id,\n      _id = _ref._id,\n      entityId = _ref.entityId,\n      __typename = _ref.__typename;\n  return id || _id || entityId ? \"\".concat(__typename, \":\").concat(id || _id || entityId) : undefined;\n};\n\nvar defaultCacheOptions = {\n  dataIdFromObject: dataIdFromObject\n};\nvar typesQuery = \"\\n  {\\n    __schema {\\n      types {\\n        kind\\n        name\\n        possibleTypes {\\n          name\\n        }\\n      }\\n    }\\n  }\\n\";\nvar instrospectionResult = null;\n/**\n * Loads instrospection data.\n * Performs a first non-client query to get GraphQL type\n * information. This process should run only once on the server.\n */\n\nvar getIntrospectionData = function getIntrospectionData() {\n  return fetch(GRAPHQL_HOST, {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: _JSON$stringify({\n      query: typesQuery\n    }),\n    method: 'POST'\n  }).then(function (result) {\n    return result.json();\n  }).then(function (result) {\n    // here we're filtering out any type information unrelated to unions or interfaces\n    var filteredData = result.data.__schema.types.filter(function (type) {\n      return type.possibleTypes !== null;\n    });\n\n    result.data.__schema.types = filteredData;\n    return result.data;\n  });\n};\n/**\n * Instrospect the GraphQL server for type information (unions, interface, etc.).\n * Either get data from a new query execution or from an already fetched instrospetion result\n */\n\n\nexport var introspect =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = instrospectionResult;\n\n            if (_context.t0) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 4;\n            return getIntrospectionData();\n\n          case 4:\n            _context.t0 = instrospectionResult = _context.sent;\n\n          case 5:\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function introspect() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Creates a new ApolloClient instance.\n *\n * @param {Object} initialState Hydrating state.\n * @return {ApolloClient}.\n */\n\nvar create = function create(_ref3) {\n  var context = _ref3.context,\n      _ref3$initialState = _ref3.initialState,\n      initialState = _ref3$initialState === void 0 ? {} : _ref3$initialState,\n      _ref3$cacheOptions = _ref3.cacheOptions,\n      cacheOptions = _ref3$cacheOptions === void 0 ? {} : _ref3$cacheOptions;\n  return new ApolloClient({\n    connectToDevTools: isClient() && isDevelopment(),\n    ssrMode: isServer(),\n    // Disables forceFetch on the server (so queries are only run once)\n    link: createHttpLink({\n      uri: GRAPHQL_HOST\n    }),\n    cache: new InMemoryCache(_objectSpread({}, defaultCacheOptions, cacheOptions)).restore(initialState)\n  });\n};\n\nvar apolloClient = null;\n/**\n * Initialize ApolloClient for either server ou client side.\n *\n * @param {Object} options.initialState\n * @param {Object} options.context\n * @param {Object} options.cache\n */\n\nexport default (function (options) {\n  return isClient() // \"client-side?\"\n  // On the CLIENT, always reuse any available ApolloClient instance.\n  ? apolloClient || (apolloClient = create(options)) // On the SERVER, always create a new ApolloClient instance.\n  // @TODO: we should reconsider this. Maybe it is best to consider SSR execution\n  // as an anonymous request always, and let contextual data be handled on the client,\n  // thus improving performance for the majority of users, which are anonymous.\n  : create(options);\n});","map":{"version":3,"sources":["/drupal/app/next/src/lib/initApollo.js"],"names":["process","fetch","ApolloClient","InMemoryCache","createHttpLink","isDevelopment","isClient","isServer","GRAPHQL_HOST","env","Error","fetcher","global","uri","options","credentials","dataIdFromObject","id","_id","entityId","__typename","undefined","defaultCacheOptions","typesQuery","instrospectionResult","getIntrospectionData","headers","body","query","method","then","result","json","filteredData","data","__schema","types","filter","type","possibleTypes","introspect","create","context","initialState","cacheOptions","connectToDevTools","ssrMode","link","cache","restore","apolloClient"],"mappings":"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","sourcesContent":["import process from 'process'\nimport fetch from 'isomorphic-fetch'\nimport { ApolloClient } from 'apollo-client'\nimport { InMemoryCache } from 'apollo-cache-inmemory'\nimport { createHttpLink } from 'apollo-link-http'\n\nimport { isDevelopment, isClient, isServer } from 'app/lib/func'\n\nconst GRAPHQL_HOST = process.env.GRAPHQL_HOST\n\nif (!GRAPHQL_HOST) {\n  throw new Error('You must set GRAPHQL_HOST environment variable prior to using Apollo.')\n}\n\n// Polyfill fetch() if needed. Useful for server-side code.\nconst fetcher = global.fetch || fetch\n\n// Override fetch to always include credentials.\n// @TODO: could this be done elsewhere?\nglobal.fetch = (uri, options = {}) => {\n  options.credentials = 'include'\n  return fetcher(uri, options)\n}\n\n/**\n * ID normalization. Will use, in order of precedence, a provided 'id', '_id', or\n * 'entityId' field as unique identificator, prefixed with the object's type.\n *\n * Fallbacks to default normalization system.\n *\n * @param {String} id The object's unique id.\n * @param {String} _id The object's unique id.\n * @param {String} entityId The object's unique id.\n * @param {String} __typename The object's type in GraphQL.\n *\n * @return {!String} Either a unique identificator if found, or nil.\n */\nconst dataIdFromObject = ({ id, _id, entityId, __typename }) => id || _id || entityId\n  ? `${__typename}:${id || _id || entityId}`\n  : undefined\n\nconst defaultCacheOptions = { dataIdFromObject }\n\nconst typesQuery = `\n  {\n    __schema {\n      types {\n        kind\n        name\n        possibleTypes {\n          name\n        }\n      }\n    }\n  }\n`\n\nlet instrospectionResult = null\n\n/**\n * Loads instrospection data.\n * Performs a first non-client query to get GraphQL type\n * information. This process should run only once on the server.\n */\nconst getIntrospectionData = () => fetch(GRAPHQL_HOST, {\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ query: typesQuery }),\n  method: 'POST'\n})\n  .then(result => result.json())\n  .then(result => {\n    // here we're filtering out any type information unrelated to unions or interfaces\n    const filteredData = result.data.__schema.types.filter(\n      type => type.possibleTypes !== null,\n    )\n    result.data.__schema.types = filteredData\n\n    return result.data\n  })\n\n/**\n * Instrospect the GraphQL server for type information (unions, interface, etc.).\n * Either get data from a new query execution or from an already fetched instrospetion result\n */\nexport const introspect = async () => instrospectionResult || (instrospectionResult = await getIntrospectionData())\n\n/**\n * Creates a new ApolloClient instance.\n *\n * @param {Object} initialState Hydrating state.\n * @return {ApolloClient}.\n */\nconst create = ({\n  context,\n  initialState = {},\n  cacheOptions = {},\n}) => new ApolloClient({\n  connectToDevTools: isClient() && isDevelopment(),\n  ssrMode: isServer(), // Disables forceFetch on the server (so queries are only run once)\n  link: createHttpLink({ uri: GRAPHQL_HOST }),\n  cache: new InMemoryCache({ ...defaultCacheOptions, ...cacheOptions })\n    .restore(initialState)\n})\n\nlet apolloClient = null\n\n/**\n * Initialize ApolloClient for either server ou client side.\n *\n * @param {Object} options.initialState\n * @param {Object} options.context\n * @param {Object} options.cache\n */\nexport default options => isClient() // \"client-side?\"\n  // On the CLIENT, always reuse any available ApolloClient instance.\n  ? apolloClient || (apolloClient = create(options))\n\n  // On the SERVER, always create a new ApolloClient instance.\n  // @TODO: we should reconsider this. Maybe it is best to consider SSR execution\n  // as an anonymous request always, and let contextual data be handled on the client,\n  // thus improving performance for the majority of users, which are anonymous.\n  : create(options)\n"]},"metadata":{},"sourceType":"module"}