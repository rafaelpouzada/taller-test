{"ast":null,"code":"\"use strict\";\n\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport * as R from 'ramda';\nimport { every } from 'conducer'; // import isURL from 'is-url'\n\nvar isEmpty = function isEmpty(value) {\n  return typeof value === 'undefined' || _Array$isArray(value) && value.length === 0 || value === null || value === '';\n};\n\nvar isNotEmpty = R.complement(isEmpty);\n\nvar isNotEmail = function isNotEmail(value) {\n  return !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value);\n}; // const isNotNumeric = value => !/^(\\d+(\\.\\d+)?)$/.test(value)\n// const isNotInteger = value => Number(value) !== Math.floor(value)\n// const isNotURL = R.complement(isURL)\n\n/*\n * Validation rules.\n */\n\n\nexport var nil = function nil() {\n  return undefined;\n};\nexport var required = function required(value) {\n  return isEmpty(value) && 'Required';\n}; // export const url = value => every([isNotEmpty, isNotURL])(value) && 'Invalid URL'\n\nexport var email = function email(value) {\n  return every([isNotEmpty, isNotEmail])(value) && 'Must be a valid e-mail';\n}; // export const number = value => every([isNotEmpty, isNotNumeric])(value) && 'Digite apenas números'\n// export const integer = value => number(value) || isNotInteger(value) && 'Digite apenas números inteiros'\n// export const checked = value => !value && 'Este campo deve estar marcado'\n// export const min = min => value => value < min && `Número deve ser maior ou igual a ${min}`\n// export const max = max => value => value >= max && `Número deve ser menor que ${max}`\n\nexport var equalsField = function equalsField(field, label) {\n  return function (value, values) {\n    return value !== values[field] && \"Must equal field \".concat(label);\n  };\n}; // export const oneOf = (options = [], error = 'Opção inválida', caseSensitive = true) =>\n//   value => options\n//     .map(str => caseSensitive ? str : str.toLowerCase())\n//     .indexOf(caseSensitive ? value : value && value.toLowerCase()) === -1 && error\n// export const maxLength = max => value => {\n//   if (!isEmpty(value) && value.length > max) {\n//     return `Não deve ter mais de ${max} caracteres`\n//   }\n// }\n\nexport var minLength = function minLength(min) {\n  return function (value) {\n    if (!isEmpty(value) && value.length < min) {\n      return \"Must have at least \".concat(min, \" characters\");\n    }\n  };\n};\n/*\n * Combine multiple validation rules into one..\n */\n\nexport var combine = function combine(rules) {\n  return function () {\n    var _rules = [].concat(rules);\n\n    for (var i = 0; i < _rules.length; i++) {\n      var error = _rules[i].apply(_rules, arguments);\n\n      if (error) return error;\n    }\n  };\n};\n/**\n * Conditionally validates a field.\n *\n * @param {Function} condition Callback to check if should validate. Receives the field\n *                             value as first argument and the whole form data as second.\n * @param {Array|Function} rules Either a single rule function or an array of rules.\n *\n * @return {Function} A configured conditional rule.\n */\n\nexport var condition = function condition(_condition, rules) {\n  return function () {\n    return _condition.apply(void 0, arguments) ? combine(rules).apply(void 0, arguments) : undefined;\n  };\n};\n/**\n * Branch validate based on field current value.\n *\n * @param {Function} test Branch predicate.\n * @param {Array|Function} leftRules Rules to apply when predicates true.\n * @param {Array|Function} rightRules Rules to apply when predicates false.\n */\n\nexport var branch = function branch(test, leftRules) {\n  var rightRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : nil;\n  return function () {\n    return combine(test.apply(void 0, arguments) ? leftRules : rightRules).apply(void 0, arguments);\n  };\n};","map":{"version":3,"sources":["/drupal/app/next/src/lib/form/validation.js"],"names":["R","every","isEmpty","value","length","isNotEmpty","complement","isNotEmail","test","nil","undefined","required","email","equalsField","field","label","values","minLength","min","combine","rules","_rules","concat","i","error","condition","branch","leftRules","rightRules"],"mappings":";;;AAAA,OAAO,KAAKA,CAAZ,MAAmB,OAAnB;AACA,SAASC,KAAT,QAAsB,UAAtB,C,CACA;;AAEA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAAC,KAAK;AAAA,SAAI,OAAOA,KAAP,KAAiB,WAAjB,IACtB,eAAcA,KAAd,KAAwBA,KAAK,CAACC,MAAN,KAAiB,CADnB,IAEvBD,KAAK,KAAK,IAFa,IAGvBA,KAAK,KAAK,EAHS;AAAA,CAArB;;AAKA,IAAME,UAAU,GAAGL,CAAC,CAACM,UAAF,CAAaJ,OAAb,CAAnB;;AACA,IAAMK,UAAU,GAAG,SAAbA,UAAa,CAAAJ,KAAK;AAAA,SAAI,CAAC,4CAA4CK,IAA5C,CAAiDL,KAAjD,CAAL;AAAA,CAAxB,C,CACA;AACA;AACA;;AAEA;;;;;AAIA,OAAO,IAAMM,GAAG,GAAG,SAANA,GAAM;AAAA,SAAMC,SAAN;AAAA,CAAZ;AACP,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAR,KAAK;AAAA,SAAID,OAAO,CAACC,KAAD,CAAP,IAAkB,UAAtB;AAAA,CAAtB,C,CACP;;AACA,OAAO,IAAMS,KAAK,GAAG,SAARA,KAAQ,CAAAT,KAAK;AAAA,SAAIF,KAAK,CAAC,CAACI,UAAD,EAAaE,UAAb,CAAD,CAAL,CAAgCJ,KAAhC,KAA0C,wBAA9C;AAAA,CAAnB,C,CACP;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMU,WAAW,GAAG,SAAdA,WAAc,CAACC,KAAD,EAAQC,KAAR;AAAA,SAAkB,UAACZ,KAAD,EAAQa,MAAR;AAAA,WAC3Cb,KAAK,KAAKa,MAAM,CAACF,KAAD,CAAhB,+BAA+CC,KAA/C,CAD2C;AAAA,GAAlB;AAAA,CAApB,C,CAGP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAME,SAAS,GAAG,SAAZA,SAAY,CAAAC,GAAG;AAAA,SAAI,UAAAf,KAAK,EAAI;AACvC,QAAI,CAACD,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,CAACC,MAAN,GAAec,GAAtC,EAA2C;AACzC,0CAA6BA,GAA7B;AACD;AACF,GAJ2B;AAAA,CAArB;AAMP;;;;AAGA,OAAO,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAAC,KAAK;AAAA,SAAI,YAAa;AAC3C,QAAMC,MAAM,GAAG,GAAGC,MAAH,CAAUF,KAAV,CAAf;;AAEA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACjB,MAA3B,EAAmCmB,CAAC,EAApC,EAAwC;AACtC,UAAMC,KAAK,GAAGH,MAAM,CAACE,CAAD,CAAN,OAAAF,MAAM,YAApB;;AACA,UAAIG,KAAJ,EAAW,OAAOA,KAAP;AACZ;AACF,GAP2B;AAAA,CAArB;AASP;;;;;;;;;;AASA,OAAO,IAAMC,SAAS,GAAG,mBAACA,UAAD,EAAYL,KAAZ;AAAA,SAAsB;AAAA,WAC7CK,UAAS,MAAT,sBAAqBN,OAAO,CAACC,KAAD,CAAP,yBAArB,GAA+CV,SADF;AAAA,GAAtB;AAAA,CAAlB;AAGP;;;;;;;;AAOA,OAAO,IAAMgB,MAAM,GAAG,SAATA,MAAS,CAAClB,IAAD,EAAOmB,SAAP;AAAA,MAAkBC,UAAlB,uEAA+BnB,GAA/B;AAAA,SAAuC;AAAA,WAC3DU,OAAO,CAACX,IAAI,MAAJ,sBAAgBmB,SAAhB,GAA4BC,UAA7B,CAAP,yBAD2D;AAAA,GAAvC;AAAA,CAAf","sourcesContent":["import * as R from 'ramda'\nimport { every } from 'conducer'\n// import isURL from 'is-url'\n\nconst isEmpty = value => typeof value === 'undefined' ||\n  (Array.isArray(value) && value.length === 0) ||\n  value === null ||\n  value === ''\n\nconst isNotEmpty = R.complement(isEmpty)\nconst isNotEmail = value => !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value)\n// const isNotNumeric = value => !/^(\\d+(\\.\\d+)?)$/.test(value)\n// const isNotInteger = value => Number(value) !== Math.floor(value)\n// const isNotURL = R.complement(isURL)\n\n/*\n * Validation rules.\n */\n\nexport const nil = () => undefined\nexport const required = value => isEmpty(value) && 'Required'\n// export const url = value => every([isNotEmpty, isNotURL])(value) && 'Invalid URL'\nexport const email = value => every([isNotEmpty, isNotEmail])(value) && 'Must be a valid e-mail'\n// export const number = value => every([isNotEmpty, isNotNumeric])(value) && 'Digite apenas números'\n// export const integer = value => number(value) || isNotInteger(value) && 'Digite apenas números inteiros'\n// export const checked = value => !value && 'Este campo deve estar marcado'\n// export const min = min => value => value < min && `Número deve ser maior ou igual a ${min}`\n// export const max = max => value => value >= max && `Número deve ser menor que ${max}`\n\nexport const equalsField = (field, label) => (value, values) =>\n  value !== values[field] && `Must equal field ${label}`\n\n// export const oneOf = (options = [], error = 'Opção inválida', caseSensitive = true) =>\n//   value => options\n//     .map(str => caseSensitive ? str : str.toLowerCase())\n//     .indexOf(caseSensitive ? value : value && value.toLowerCase()) === -1 && error\n\n// export const maxLength = max => value => {\n//   if (!isEmpty(value) && value.length > max) {\n//     return `Não deve ter mais de ${max} caracteres`\n//   }\n// }\n\nexport const minLength = min => value => {\n  if (!isEmpty(value) && value.length < min) {\n    return `Must have at least ${min} characters`\n  }\n}\n\n/*\n * Combine multiple validation rules into one..\n */\nexport const combine = rules => (...args) => {\n  const _rules = [].concat(rules)\n\n  for (let i = 0; i < _rules.length; i++) {\n    const error = _rules[i](...args)\n    if (error) return error\n  }\n}\n\n/**\n * Conditionally validates a field.\n *\n * @param {Function} condition Callback to check if should validate. Receives the field\n *                             value as first argument and the whole form data as second.\n * @param {Array|Function} rules Either a single rule function or an array of rules.\n *\n * @return {Function} A configured conditional rule.\n */\nexport const condition = (condition, rules) => (...args) =>\n  condition(...args) ? combine(rules)(...args) : undefined\n\n/**\n * Branch validate based on field current value.\n *\n * @param {Function} test Branch predicate.\n * @param {Array|Function} leftRules Rules to apply when predicates true.\n * @param {Array|Function} rightRules Rules to apply when predicates false.\n */\nexport const branch = (test, leftRules, rightRules = nil) => (...args) =>\n  combine(test(...args) ? leftRules : rightRules)(...args)\n"]},"metadata":{},"sourceType":"module"}