{"ast":null,"code":"\"use strict\";\n\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport * as R from 'ramda';\nimport { every } from 'conducer'; // import isURL from 'is-url'\n\nconst isEmpty = value => typeof value === 'undefined' || _Array$isArray(value) && value.length === 0 || value === null || value === '';\n\nconst isNotEmpty = R.complement(isEmpty);\n\nconst isNotEmail = value => !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value); // const isNotNumeric = value => !/^(\\d+(\\.\\d+)?)$/.test(value)\n// const isNotInteger = value => Number(value) !== Math.floor(value)\n// const isNotURL = R.complement(isURL)\n\n/*\n * Validation rules.\n */\n\n\nexport const nil = () => undefined;\nexport const required = value => isEmpty(value) && 'Required'; // export const url = value => every([isNotEmpty, isNotURL])(value) && 'Invalid URL'\n\nexport const email = value => every([isNotEmpty, isNotEmail])(value) && 'Must be a valid e-mail'; // export const number = value => every([isNotEmpty, isNotNumeric])(value) && 'Digite apenas números'\n// export const integer = value => number(value) || isNotInteger(value) && 'Digite apenas números inteiros'\n// export const checked = value => !value && 'Este campo deve estar marcado'\n// export const min = min => value => value < min && `Número deve ser maior ou igual a ${min}`\n// export const max = max => value => value >= max && `Número deve ser menor que ${max}`\n\nexport const equalsField = (field, label) => (value, values) => value !== values[field] && `Must equal field ${label}`; // export const oneOf = (options = [], error = 'Opção inválida', caseSensitive = true) =>\n//   value => options\n//     .map(str => caseSensitive ? str : str.toLowerCase())\n//     .indexOf(caseSensitive ? value : value && value.toLowerCase()) === -1 && error\n// export const maxLength = max => value => {\n//   if (!isEmpty(value) && value.length > max) {\n//     return `Não deve ter mais de ${max} caracteres`\n//   }\n// }\n\nexport const minLength = min => value => {\n  if (!isEmpty(value) && value.length < min) {\n    return `Must have at least ${min} characters`;\n  }\n};\n/*\n * Combine multiple validation rules into one..\n */\n\nexport const combine = rules => (...args) => {\n  const _rules = [].concat(rules);\n\n  for (let i = 0; i < _rules.length; i++) {\n    const error = _rules[i](...args);\n\n    if (error) return error;\n  }\n};\n/**\n * Conditionally validates a field.\n *\n * @param {Function} condition Callback to check if should validate. Receives the field\n *                             value as first argument and the whole form data as second.\n * @param {Array|Function} rules Either a single rule function or an array of rules.\n *\n * @return {Function} A configured conditional rule.\n */\n\nexport const condition = (condition, rules) => (...args) => condition(...args) ? combine(rules)(...args) : undefined;\n/**\n * Branch validate based on field current value.\n *\n * @param {Function} test Branch predicate.\n * @param {Array|Function} leftRules Rules to apply when predicates true.\n * @param {Array|Function} rightRules Rules to apply when predicates false.\n */\n\nexport const branch = (test, leftRules, rightRules = nil) => (...args) => combine(test(...args) ? leftRules : rightRules)(...args);","map":{"version":3,"sources":["/drupal/app/next/src/lib/form/validation.js"],"names":["R","every","isEmpty","value","length","isNotEmpty","complement","isNotEmail","test","nil","undefined","required","email","equalsField","field","label","values","minLength","min","combine","rules","args","_rules","concat","i","error","condition","branch","leftRules","rightRules"],"mappings":";;;AAAA,OAAO,KAAKA,CAAZ,MAAmB,OAAnB;AACA,SAASC,KAAT,QAAsB,UAAtB,C,CACA;;AAEA,MAAMC,OAAO,GAAGC,KAAK,IAAI,OAAOA,KAAP,KAAiB,WAAjB,IACtB,eAAcA,KAAd,KAAwBA,KAAK,CAACC,MAAN,KAAiB,CADnB,IAEvBD,KAAK,KAAK,IAFa,IAGvBA,KAAK,KAAK,EAHZ;;AAKA,MAAME,UAAU,GAAGL,CAAC,CAACM,UAAF,CAAaJ,OAAb,CAAnB;;AACA,MAAMK,UAAU,GAAGJ,KAAK,IAAI,CAAC,4CAA4CK,IAA5C,CAAiDL,KAAjD,CAA7B,C,CACA;AACA;AACA;;AAEA;;;;;AAIA,OAAO,MAAMM,GAAG,GAAG,MAAMC,SAAlB;AACP,OAAO,MAAMC,QAAQ,GAAGR,KAAK,IAAID,OAAO,CAACC,KAAD,CAAP,IAAkB,UAA5C,C,CACP;;AACA,OAAO,MAAMS,KAAK,GAAGT,KAAK,IAAIF,KAAK,CAAC,CAACI,UAAD,EAAaE,UAAb,CAAD,CAAL,CAAgCJ,KAAhC,KAA0C,wBAAjE,C,CACP;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMU,WAAW,GAAG,CAACC,KAAD,EAAQC,KAAR,KAAkB,CAACZ,KAAD,EAAQa,MAAR,KAC3Cb,KAAK,KAAKa,MAAM,CAACF,KAAD,CAAhB,IAA4B,oBAAmBC,KAAM,EADhD,C,CAGP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAME,SAAS,GAAGC,GAAG,IAAIf,KAAK,IAAI;AACvC,MAAI,CAACD,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,CAACC,MAAN,GAAec,GAAtC,EAA2C;AACzC,WAAQ,sBAAqBA,GAAI,aAAjC;AACD;AACF,CAJM;AAMP;;;;AAGA,OAAO,MAAMC,OAAO,GAAGC,KAAK,IAAI,CAAC,GAAGC,IAAJ,KAAa;AAC3C,QAAMC,MAAM,GAAG,GAAGC,MAAH,CAAUH,KAAV,CAAf;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAAClB,MAA3B,EAAmCoB,CAAC,EAApC,EAAwC;AACtC,UAAMC,KAAK,GAAGH,MAAM,CAACE,CAAD,CAAN,CAAU,GAAGH,IAAb,CAAd;;AACA,QAAII,KAAJ,EAAW,OAAOA,KAAP;AACZ;AACF,CAPM;AASP;;;;;;;;;;AASA,OAAO,MAAMC,SAAS,GAAG,CAACA,SAAD,EAAYN,KAAZ,KAAsB,CAAC,GAAGC,IAAJ,KAC7CK,SAAS,CAAC,GAAGL,IAAJ,CAAT,GAAqBF,OAAO,CAACC,KAAD,CAAP,CAAe,GAAGC,IAAlB,CAArB,GAA+CX,SAD1C;AAGP;;;;;;;;AAOA,OAAO,MAAMiB,MAAM,GAAG,CAACnB,IAAD,EAAOoB,SAAP,EAAkBC,UAAU,GAAGpB,GAA/B,KAAuC,CAAC,GAAGY,IAAJ,KAC3DF,OAAO,CAACX,IAAI,CAAC,GAAGa,IAAJ,CAAJ,GAAgBO,SAAhB,GAA4BC,UAA7B,CAAP,CAAgD,GAAGR,IAAnD,CADK","sourcesContent":["import * as R from 'ramda'\nimport { every } from 'conducer'\n// import isURL from 'is-url'\n\nconst isEmpty = value => typeof value === 'undefined' ||\n  (Array.isArray(value) && value.length === 0) ||\n  value === null ||\n  value === ''\n\nconst isNotEmpty = R.complement(isEmpty)\nconst isNotEmail = value => !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value)\n// const isNotNumeric = value => !/^(\\d+(\\.\\d+)?)$/.test(value)\n// const isNotInteger = value => Number(value) !== Math.floor(value)\n// const isNotURL = R.complement(isURL)\n\n/*\n * Validation rules.\n */\n\nexport const nil = () => undefined\nexport const required = value => isEmpty(value) && 'Required'\n// export const url = value => every([isNotEmpty, isNotURL])(value) && 'Invalid URL'\nexport const email = value => every([isNotEmpty, isNotEmail])(value) && 'Must be a valid e-mail'\n// export const number = value => every([isNotEmpty, isNotNumeric])(value) && 'Digite apenas números'\n// export const integer = value => number(value) || isNotInteger(value) && 'Digite apenas números inteiros'\n// export const checked = value => !value && 'Este campo deve estar marcado'\n// export const min = min => value => value < min && `Número deve ser maior ou igual a ${min}`\n// export const max = max => value => value >= max && `Número deve ser menor que ${max}`\n\nexport const equalsField = (field, label) => (value, values) =>\n  value !== values[field] && `Must equal field ${label}`\n\n// export const oneOf = (options = [], error = 'Opção inválida', caseSensitive = true) =>\n//   value => options\n//     .map(str => caseSensitive ? str : str.toLowerCase())\n//     .indexOf(caseSensitive ? value : value && value.toLowerCase()) === -1 && error\n\n// export const maxLength = max => value => {\n//   if (!isEmpty(value) && value.length > max) {\n//     return `Não deve ter mais de ${max} caracteres`\n//   }\n// }\n\nexport const minLength = min => value => {\n  if (!isEmpty(value) && value.length < min) {\n    return `Must have at least ${min} characters`\n  }\n}\n\n/*\n * Combine multiple validation rules into one..\n */\nexport const combine = rules => (...args) => {\n  const _rules = [].concat(rules)\n\n  for (let i = 0; i < _rules.length; i++) {\n    const error = _rules[i](...args)\n    if (error) return error\n  }\n}\n\n/**\n * Conditionally validates a field.\n *\n * @param {Function} condition Callback to check if should validate. Receives the field\n *                             value as first argument and the whole form data as second.\n * @param {Array|Function} rules Either a single rule function or an array of rules.\n *\n * @return {Function} A configured conditional rule.\n */\nexport const condition = (condition, rules) => (...args) =>\n  condition(...args) ? combine(rules)(...args) : undefined\n\n/**\n * Branch validate based on field current value.\n *\n * @param {Function} test Branch predicate.\n * @param {Array|Function} leftRules Rules to apply when predicates true.\n * @param {Array|Function} rightRules Rules to apply when predicates false.\n */\nexport const branch = (test, leftRules, rightRules = nil) => (...args) =>\n  combine(test(...args) ? leftRules : rightRules)(...args)\n"]},"metadata":{},"sourceType":"module"}